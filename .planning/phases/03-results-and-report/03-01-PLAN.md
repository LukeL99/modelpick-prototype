---
phase: 03-results-and-report
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/004_realtime_and_shared_runs.sql
  - src/types/report.ts
  - src/lib/report/aggregate.ts
  - src/lib/report/error-patterns.ts
  - src/lib/report/recommendation.ts
autonomous: true
user_setup:
  - service: supabase
    why: "Realtime publication and RLS policy for anonymous report viewing"
    dashboard_config:
      - task: "Run migration 004_realtime_and_shared_runs.sql in Supabase SQL Editor"
        location: "Supabase Dashboard -> SQL Editor"

must_haves:
  truths:
    - "benchmark_runs and reports tables are added to supabase_realtime publication"
    - "Anonymous users can SELECT benchmark_runs for reports that have a share_token"
    - "Raw benchmark_runs can be aggregated into per-model summaries with accuracy, cost, latency, spread"
    - "Field errors can be grouped into patterns showing which fields each model misses most"
    - "A recommendation rationale can be generated from model aggregates and user priorities"
  artifacts:
    - path: "supabase/migrations/004_realtime_and_shared_runs.sql"
      provides: "Realtime publication + anonymous RLS policy for benchmark_runs"
      contains: "ALTER PUBLICATION supabase_realtime"
    - path: "src/types/report.ts"
      provides: "Report view model types for UI components"
      exports: ["ModelSummary", "FieldErrorSummary", "ErrorPattern", "ReportData"]
    - path: "src/lib/report/aggregate.ts"
      provides: "Transform raw benchmark_runs into ModelSummary array"
      exports: ["transformRunsToReport"]
    - path: "src/lib/report/error-patterns.ts"
      provides: "Aggregate field errors into patterns per model"
      exports: ["aggregateErrorPatterns"]
    - path: "src/lib/report/recommendation.ts"
      provides: "Generate recommendation rationale text"
      exports: ["generateRationale"]
  key_links:
    - from: "src/lib/report/aggregate.ts"
      to: "src/lib/config/models.ts"
      via: "getModelById for model name/provider/tier lookup"
      pattern: "getModelById"
    - from: "src/types/report.ts"
      to: "src/types/database.ts"
      via: "BenchmarkRun type for raw run references"
      pattern: "BenchmarkRun"
---

<objective>
Create the database migration for Supabase Realtime support and anonymous report access, plus the server-side data transformation layer that converts raw benchmark_runs into the view models needed by all Phase 3 report components.

Purpose: Every report UI component depends on pre-computed aggregates (ModelSummary, ErrorPattern, rationale text). Building this data layer first enables all subsequent report component plans to run in parallel.

Output: Migration SQL file, report types, and three pure-function utility modules (aggregate, error-patterns, recommendation).
</objective>

<execution_context>
@/Users/lukelibraro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lukelibraro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-results-and-report/03-RESEARCH.md

# Key source files for understanding existing data structures
@src/types/database.ts
@src/types/benchmark.ts
@src/lib/config/models.ts
@src/lib/benchmark/engine.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Database migration for Realtime publication and anonymous benchmark_runs access</name>
  <files>supabase/migrations/004_realtime_and_shared_runs.sql</files>
  <action>
Create migration file `supabase/migrations/004_realtime_and_shared_runs.sql` with:

1. **Enable Realtime replication** for benchmark_runs and reports tables:
   ```sql
   ALTER PUBLICATION supabase_realtime ADD TABLE benchmark_runs;
   ALTER PUBLICATION supabase_realtime ADD TABLE reports;
   ```
   This is REQUIRED for Supabase Realtime postgres_changes events to fire (see research Pitfall 1).

2. **Add anonymous SELECT policy for benchmark_runs** so shareable report links work without login:
   ```sql
   CREATE POLICY "Anyone can view runs for shared reports"
     ON benchmark_runs FOR SELECT
     TO anon, authenticated
     USING (
       EXISTS (
         SELECT 1 FROM reports
         WHERE reports.id = benchmark_runs.report_id
         AND reports.share_token IS NOT NULL
       )
     );
   ```
   Without this, anonymous visitors to `/report/[token]` can see the report row (via existing anon policy on reports) but NOT the benchmark_runs data (see research Pitfall 5).

3. **Add comment** documenting that this supplements migration 003 which only had an authenticated-user policy.

Do NOT add REPLICA IDENTITY FULL -- the default REPLICA IDENTITY (primary key) is sufficient since we only need the `new` row on INSERT/UPDATE events, not the `old` row.
  </action>
  <verify>
File exists at `supabase/migrations/004_realtime_and_shared_runs.sql` and contains:
- `ALTER PUBLICATION supabase_realtime ADD TABLE benchmark_runs`
- `ALTER PUBLICATION supabase_realtime ADD TABLE reports`
- `CREATE POLICY` with `TO anon, authenticated` on benchmark_runs
- Subquery checking `reports.share_token IS NOT NULL`
  </verify>
  <done>Migration file ready for user to run in Supabase SQL Editor. Enables Realtime events and anonymous report viewing.</done>
</task>

<task type="auto">
  <name>Task 2: Report types and server-side data transformation utilities</name>
  <files>
    src/types/report.ts
    src/lib/report/aggregate.ts
    src/lib/report/error-patterns.ts
    src/lib/report/recommendation.ts
  </files>
  <action>
**Step A: Create `src/types/report.ts`** with view model types used by all report components:

```typescript
export interface ModelSummary {
  modelId: string;
  modelName: string;
  provider: string;
  tier: string;
  accuracy: number;          // avg field_accuracy as percentage (0-100)
  exactMatchRate: number;    // % of runs with exact_match (0-100)
  costPerRun: number;        // avg actual_cost in USD
  medianLatency: number;     // median response_time_ms
  p95Latency: number;        // 95th percentile response_time_ms
  spread: number;            // std dev of field_accuracy
  runsCompleted: number;
  runsAttempted: number;
}

export interface FieldErrorSummary {
  fieldPath: string;
  expected: string;
  actual: string;
  occurrences: number;
  percentage: number;        // occurrences / totalRuns * 100
}

export interface ErrorPattern {
  modelName: string;
  modelId: string;
  fieldPath: string;
  occurrences: number;
  totalRuns: number;
  percentage: number;
  commonExpected: string;
  commonActual: string;      // most frequent incorrect value
}

export interface ReportData {
  models: ModelSummary[];
  recommendedModelId: string | null;
  totalApiCost: number;
  rationale: string;
  priorities: string[];
  imageCount: number;
  modelCount: number;
  startedAt: string | null;
  completedAt: string | null;
}
```

**Step B: Create `src/lib/report/aggregate.ts`** -- `transformRunsToReport()` function:

- Import `BenchmarkRun`, `Report` from `@/types/database`, `getModelById` from `@/lib/config/models`, types from `@/types/report`
- Group runs by `model_id` using a Map
- For each model, calculate (matching engine.ts Step 5 logic exactly):
  - `accuracy`: average of `field_accuracy` values from completed runs (field_accuracy is already 0-100 from engine)
  - `exactMatchRate`: count of `exact_match === true` / completed runs * 100
  - `costPerRun`: average of `actual_cost` from completed runs
  - `medianLatency`: sort latencies, take middle value
  - `p95Latency`: sort latencies, take element at `ceil(0.95 * length) - 1`
  - `spread`: standard deviation of field_accuracy values
- Look up model name/provider/tier via `getModelById(modelId)`, fall back to modelId/"unknown"/"unknown"
- Sort models by accuracy descending as default order
- Return `ReportData` object with models array, recommendedModelId from report.recommended_model, totalApiCost from report.total_api_cost, and metadata from report and config_snapshot

Also export a helper: `getModelFieldErrors(runs: BenchmarkRun[]): FieldErrorSummary[]` that aggregates field_errors from all completed runs for a single model into unique (fieldPath, expected, actual) groups with occurrence counts.

**Step C: Create `src/lib/report/error-patterns.ts`** -- `aggregateErrorPatterns()` function:

- Takes an array of `ModelSummary` entries and a `Map<string, BenchmarkRun[]>` of runs grouped by modelId
- For each model, iterate completed runs, extract `field_errors` array (typed as `Array<{ fieldPath: string; expected: string; actual: string }>`)
- Group by `(modelId, fieldPath)`, count occurrences, find most common actual value
- Calculate percentage = occurrences / totalCompletedRuns * 100
- Return sorted by occurrences descending, then by percentage descending
- Filter to patterns with percentage >= 10 (ignore rare one-off errors)

**Step D: Create `src/lib/report/recommendation.ts`** -- `generateRationale()` function:

- Takes `recommended: ModelSummary`, `allModels: ModelSummary[]`, `priorities: string[]`
- Build human-readable rationale based on top priority:
  - accuracy: "{name} achieved {accuracy}% field accuracy"
  - speed: "{name} responded in {median}ms median"
  - cost: "{name} costs ${cost}/call"
- Add savings comparison vs most expensive model if savings > 10%
- Add consistency note if spread < 5: "with consistent results (Â±{spread}%)"
- Return concatenated string with period at end

All functions must be pure (no side effects, no database calls) -- they receive data as arguments.
  </action>
  <verify>
1. `npx tsc --noEmit` passes with no errors
2. All four files exist and export their documented functions/types
3. `aggregate.ts` imports from `@/types/database`, `@/lib/config/models`, `@/types/report`
4. `error-patterns.ts` imports from `@/types/report` and `@/types/database`
5. `recommendation.ts` imports from `@/types/report`
  </verify>
  <done>Report data layer complete: types defined, aggregate transformation builds ModelSummary array from raw runs, error patterns aggregated per model per field, recommendation rationale generated from priorities. All pure functions ready for server-side use in report page.</done>
</task>

</tasks>

<verification>
1. Migration 004 file exists with Realtime publication and anonymous RLS policy
2. `npx tsc --noEmit` passes
3. `npm run build` succeeds
4. All exported types and functions are importable from their documented paths
</verification>

<success_criteria>
- Migration enables Supabase Realtime on benchmark_runs and reports tables
- Migration adds anonymous SELECT policy for shared reports on benchmark_runs
- transformRunsToReport() converts raw BenchmarkRun[] into ReportData with ModelSummary[]
- aggregateErrorPatterns() groups field errors into patterns with percentages
- generateRationale() produces human-readable recommendation text
- All code compiles without TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-results-and-report/03-01-SUMMARY.md`
</output>
