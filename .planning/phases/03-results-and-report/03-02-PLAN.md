---
phase: 03-results-and-report
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/components/benchmark/live-progress.tsx
  - src/app/(app)/benchmark/[id]/processing/page.tsx
autonomous: true

must_haves:
  truths:
    - "User sees real-time progress as each model completes during benchmark execution"
    - "Progress shows model name, completion count, and running/complete status per model"
    - "Connection auto-reconnects if dropped (Supabase client handles this natively)"
    - "User sees connection status indicator (connected/reconnecting)"
    - "Processing page auto-redirects to report when benchmark completes"
  artifacts:
    - path: "src/components/benchmark/live-progress.tsx"
      provides: "Realtime progress panel with per-model progress bars"
      exports: ["LiveProgress"]
    - path: "src/app/(app)/benchmark/[id]/processing/page.tsx"
      provides: "Processing page with live progress client island"
      contains: "LiveProgress"
  key_links:
    - from: "src/components/benchmark/live-progress.tsx"
      to: "Supabase Realtime"
      via: "channel.on('postgres_changes', { table: 'benchmark_runs' })"
      pattern: "postgres_changes"
    - from: "src/components/benchmark/live-progress.tsx"
      to: "src/lib/supabase/client.ts"
      via: "createClient() for browser-side subscription"
      pattern: "createClient"
    - from: "src/app/(app)/benchmark/[id]/processing/page.tsx"
      to: "src/components/benchmark/live-progress.tsx"
      via: "Client island import in server component page"
      pattern: "LiveProgress"
---

<objective>
Add real-time benchmark progress display to the processing page using Supabase Realtime postgres_changes subscriptions, replacing the current static spinner with a live per-model progress panel that auto-redirects to the report on completion.

Purpose: Fulfills LIVE-01, LIVE-02, LIVE-03 requirements. Users see exactly which models are running, how many runs each has completed, and get automatically taken to their report when done.

Output: LiveProgress client component and upgraded processing page.
</objective>

<execution_context>
@/Users/lukelibraro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lukelibraro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-results-and-report/03-RESEARCH.md

# Existing processing page to modify
@src/app/(app)/benchmark/[id]/processing/page.tsx

# Supabase client for browser-side subscriptions
@src/lib/supabase/client.ts

# Types for benchmark runs
@src/types/database.ts

# Model info for display names
@src/lib/config/models.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: LiveProgress Realtime client component</name>
  <files>src/components/benchmark/live-progress.tsx</files>
  <action>
Create `src/components/benchmark/live-progress.tsx` as a `"use client"` component:

**Props interface:**
```typescript
interface LiveProgressProps {
  reportId: string;
  selectedModelIds: string[];
  totalRunsPerModel: number;  // runs per model (sampleCount * imageCount)
  shareToken: string | null;
}
```

**State:**
- `progress`: `Map<string, { modelId: string; modelName: string; completed: number; total: number; status: "pending" | "running" | "complete" }>` -- keyed by modelId
- `connected`: boolean for connection status indicator
- `reportComplete`: boolean for redirect trigger

**Realtime subscription (useEffect):**
1. Create Supabase browser client via `createClient()`
2. Subscribe to channel `benchmark-progress-${reportId}` with:
   ```
   .on("postgres_changes", {
     event: "*",
     schema: "public",
     table: "benchmark_runs",
     filter: `report_id=eq.${reportId}`,
   }, callback)
   ```
3. On each event (INSERT or UPDATE), extract `payload.new` as `BenchmarkRun`
4. Update progress map: increment completed count when status is "complete", "failed", or "skipped"
5. Mark model as "running" when first event arrives, "complete" when completed >= total
6. Subscribe to channel status: set `connected = status === "SUBSCRIBED"`
7. Cleanup: `supabase.removeChannel(channel)` in useEffect return

**Also subscribe to reports table** for completion detection:
- Listen to `postgres_changes` on `reports` table filtered by `id=eq.${reportId}`
- On UPDATE event, check if `payload.new.status === "complete"` or `"failed"`
- If complete, set `reportComplete = true`
- If failed, show error state

**Auto-redirect on completion:**
- `useEffect` watching `reportComplete`: when true, use `useRouter()` from `next/navigation` to redirect to `/report/${shareToken}` (if shareToken exists) or show a "Report ready" link
- Add a 1.5s delay before redirect so user sees the "Complete!" state briefly

**Initialize progress map** from selectedModelIds prop:
- In a `useEffect` on mount, set initial progress for each selectedModelId with completed=0, total=totalRunsPerModel, status="pending"
- Look up model display name via `getModelById(modelId)?.name ?? modelId`

**Render:**
- Connection status pill: green dot + "Live" when connected, yellow dot + "Reconnecting..." when not
- Overall progress bar: total completed / total runs across all models
- Per-model rows, each showing:
  - Model name (from getModelById)
  - Mini progress bar (completed / total)
  - Status badge: "Waiting" (gray), "Running" (ember/pulsing), "Complete" (green), "Failed" (red)
  - Fraction text: "3/10 runs"
- Use existing Tailwind palette: bg-surface for cards, text-text-primary/secondary/muted, border-surface-border, bg-ember for active progress

**Important:** Do NOT include `onRun` callback in the useEffect dependency array -- wrap the state update logic inline to avoid stale closure issues (same pattern as research code example).
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. File exports `LiveProgress` component
3. Component uses `"use client"` directive
4. Component creates Supabase channel with `postgres_changes` subscription
5. Component has useEffect cleanup calling `removeChannel`
6. Component renders per-model progress rows
  </verify>
  <done>LiveProgress component subscribes to benchmark_runs changes via Supabase Realtime, shows per-model progress with connection status, and auto-redirects on completion.</done>
</task>

<task type="auto">
  <name>Task 2: Upgrade processing page to use LiveProgress client island</name>
  <files>src/app/(app)/benchmark/[id]/processing/page.tsx</files>
  <action>
Modify the existing processing page at `src/app/(app)/benchmark/[id]/processing/page.tsx`:

**Keep the existing server component structure** (auth check, report loading, redirect if no user). Modify the page to:

1. **Load additional data** needed by LiveProgress:
   - Extract `sampleCount` from `configSnapshot.sampleCount` (number of runs per model per image)
   - Calculate `totalRunsPerModel = sampleCount * imagePaths.length` (total runs each model will execute)
   - Extract `share_token` from the report

2. **Handle report already complete:** If `typedReport.status === "complete"` and `typedReport.share_token`, redirect to `/report/${typedReport.share_token}`. If `typedReport.status === "failed"`, show an error message with link back to dashboard.

3. **Replace the current static spinner UI** with:
   - Keep the header section (title "Your benchmark is running...")
   - Keep the stats section (model count, image count)
   - Add the `<LiveProgress>` client island below the stats, passing: `reportId={id}`, `selectedModelIds={selectedModels}`, `totalRunsPerModel={totalRunsPerModel}`, `shareToken={typedReport.share_token}`
   - Keep the "You can close this page" note at the bottom

4. **Import LiveProgress** from `@/components/benchmark/live-progress`

5. **Keep the page as a server component** -- LiveProgress is a client island rendered within the server component page. The page loads report data server-side, then passes it as props to the client island.

The page should NOT have `"use client"` -- it remains a server component that loads data and renders the LiveProgress client island.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds
3. Processing page imports and renders LiveProgress
4. Processing page remains a server component (no "use client" directive)
5. Processing page passes reportId, selectedModelIds, totalRunsPerModel, and shareToken to LiveProgress
6. Processing page redirects to report page if report is already complete
  </verify>
  <done>Processing page shows real-time benchmark progress via Supabase Realtime client island. Users see per-model progress bars, connection status, and auto-redirect to report on completion. Fulfills LIVE-01, LIVE-02, LIVE-03.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds
3. Processing page renders LiveProgress component with correct props
4. LiveProgress subscribes to Supabase Realtime and handles INSERT/UPDATE events
5. Connection status indicator shows live/reconnecting state
6. Auto-redirect fires when report status changes to "complete"
</verification>

<success_criteria>
- LiveProgress component subscribes to benchmark_runs postgres_changes filtered by report_id
- Progress updates in real-time as each run INSERT/UPDATE arrives
- Each model shows name, progress bar, run count, and status badge
- Connection status indicator visible (connected/reconnecting)
- Processing page auto-redirects to /report/[token] when benchmark completes
- Cleanup removes channel subscription on unmount (no memory leak)
- Page gracefully handles already-complete or failed reports
</success_criteria>

<output>
After completion, create `.planning/phases/03-results-and-report/03-02-SUMMARY.md`
</output>
