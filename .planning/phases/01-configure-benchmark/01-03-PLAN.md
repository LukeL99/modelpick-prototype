---
phase: 01-configure-benchmark
plan: 03
type: execute
wave: 3
depends_on: ["01-01", "01-02"]
files_modified:
  - src/app/(app)/benchmark/new/page.tsx
  - src/components/wizard/wizard-shell.tsx
  - src/components/wizard/step-config.tsx
  - src/components/wizard/step-upload.tsx
  - src/components/wizard/priority-ranker.tsx
  - src/components/wizard/strategy-picker.tsx
  - src/components/wizard/image-uploader.tsx
  - src/components/wizard/image-card.tsx
  - src/components/wizard/json-editor.tsx
  - src/components/ui/step-indicator.tsx
  - src/app/api/upload/signed-url/route.ts
  - src/app/api/drafts/route.ts
  - src/app/api/drafts/[id]/route.ts
  - src/lib/supabase/queries.ts
autonomous: true

must_haves:
  truths:
    - "User can navigate to /benchmark/new and see wizard Step 1 (config) by default"
    - "User can drag to rank priorities (accuracy, speed, cost) into ordered positions"
    - "User can select a strategy preset (Quick Survey, Deep Dive, Balanced)"
    - "User can set sample count (1-10) and see it reflected"
    - "User can advance to Step 2 and upload 1-10 images via drag-and-drop with thumbnail previews"
    - "User can paste or upload JSON for each image in a CodeMirror editor with syntax highlighting"
    - "Invalid JSON shows inline validation errors (red underlines)"
    - "User can click any completed step in the wizard header to navigate back"
    - "Draft state is persisted to database -- user can leave and resume"
    - "URL reflects current step (?step=config or ?step=upload)"
  artifacts:
    - path: "src/app/(app)/benchmark/new/page.tsx"
      provides: "Wizard page with URL-persisted step state"
      contains: "useQueryState"
    - path: "src/components/wizard/wizard-shell.tsx"
      provides: "Step navigation, progress indicator, step routing"
      min_lines: 40
    - path: "src/components/wizard/priority-ranker.tsx"
      provides: "Drag-to-rank priority ordering"
      contains: "DragDropProvider"
    - path: "src/components/wizard/json-editor.tsx"
      provides: "CodeMirror JSON editor with inline validation"
      contains: "CodeMirror"
    - path: "src/components/wizard/image-uploader.tsx"
      provides: "Drag-and-drop image upload via react-dropzone"
      contains: "useDropzone"
    - path: "src/app/api/upload/signed-url/route.ts"
      provides: "Signed URL generation for Supabase Storage upload"
      exports: ["POST"]
    - path: "src/lib/supabase/queries.ts"
      provides: "Draft CRUD operations"
      exports: ["saveDraftStep", "loadDraft", "createDraft"]
  key_links:
    - from: "src/app/(app)/benchmark/new/page.tsx"
      to: "src/components/wizard/wizard-shell.tsx"
      via: "WizardShell component import"
      pattern: "import.*WizardShell"
    - from: "src/components/wizard/image-uploader.tsx"
      to: "src/app/api/upload/signed-url/route.ts"
      via: "fetch /api/upload/signed-url"
      pattern: "fetch.*api/upload/signed-url"
    - from: "src/components/wizard/wizard-shell.tsx"
      to: "src/lib/supabase/queries.ts"
      via: "Draft persistence on step transition"
      pattern: "saveDraftStep|loadDraft"
    - from: "src/components/wizard/priority-ranker.tsx"
      to: "@dnd-kit/react"
      via: "DragDropProvider and useSortable"
      pattern: "DragDropProvider|useSortable"
---

<objective>
Build the wizard shell with URL-persisted step state, Step 1 (benchmark configuration: priority ranking, strategy selection, sample count), and Step 2 (image upload with drag-and-drop and JSON editing with CodeMirror validation). Include draft persistence to Supabase and signed URL image upload.

Purpose: Deliver the core wizard experience where users configure their benchmark priorities and upload sample images with expected JSON output. These are the two most interactive and technically complex wizard steps.
Output: Working wizard at /benchmark/new with Steps 1 and 2 functional, draft state persisting to database, images uploading to Supabase Storage.
</objective>

<execution_context>
@/Users/lukelibraro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lukelibraro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-configure-benchmark/01-RESEARCH.md
@.planning/phases/01-configure-benchmark/01-CONTEXT.md
@.planning/phases/01-configure-benchmark/01-01-SUMMARY.md
@.planning/phases/01-configure-benchmark/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wizard shell, Step 1 (config), draft persistence, and API routes</name>
  <files>
    src/app/(app)/benchmark/new/page.tsx
    src/components/wizard/wizard-shell.tsx
    src/components/wizard/step-config.tsx
    src/components/wizard/priority-ranker.tsx
    src/components/wizard/strategy-picker.tsx
    src/components/ui/step-indicator.tsx
    src/app/api/drafts/route.ts
    src/app/api/drafts/[id]/route.ts
    src/lib/supabase/queries.ts
  </files>
  <action>
    **Build the wizard framework and Step 1. Follow user decisions EXACTLY: config questions come FIRST (before upload).**

    1. **Create draft API routes:**
       - `src/app/api/drafts/route.ts`:
         - POST: Create a new draft. Authenticate via server Supabase client `getUser()`. Insert into `benchmark_drafts` with `user_id`, default `status: 'draft'`. Return `{ id, ...draft }`.
       - `src/app/api/drafts/[id]/route.ts`:
         - GET: Load draft by ID. Verify user owns draft via RLS.
         - PATCH: Update draft step data. Accept `{ step: 'config'|'upload'|'schema', data: object }`. Update the corresponding JSONB column (`config_data`, `upload_data`, or `schema_data`) and `updated_at`.
       - Both routes: Return 401 if not authenticated, 404 if draft not found.

    2. **Create draft query helpers** (`src/lib/supabase/queries.ts`):
       - `createDraft(supabase)`: Insert new draft, return it.
       - `loadDraft(supabase, draftId)`: Select draft by ID, return null if not found.
       - `saveDraftStep(supabase, draftId, step, data)`: Update specific step column.
       - `getUserDrafts(supabase)`: Get all drafts for current user, ordered by updated_at desc.
       - Types should use the Database types from `src/types/database.ts`.

    3. **Create wizard page** (`src/app/(app)/benchmark/new/page.tsx`):
       - "use client" component
       - Use `useQueryState` from `nuqs` with `parseAsStringEnum(['config', 'upload', 'schema'])` defaulting to `'config'`
       - On mount: Check URL for `?draft=<id>` param. If present, load existing draft. If not, check for user's most recent "draft" status draft. If none, create a new draft.
       - Store draftId in state. Pass draft data and setters to child step components.
       - Render `<WizardShell>` wrapping the current step component.

    4. **Create wizard shell** (`src/components/wizard/wizard-shell.tsx`):
       - "use client" component
       - Props: currentStep, onStepChange, completedSteps (Set), draftId
       - Render `<StepIndicator>` at top showing 3 steps with labels: "Configure", "Upload", "Schema & Prompt"
       - Each step in the indicator: clickable if completed (per user decision: free navigation between completed steps), current step highlighted in ember, future steps grayed out
       - Below indicator: render children (the active step component)
       - Bottom bar: "Back" button (goes to previous step) and "Continue" button (goes to next step). Disable "Continue" if current step validation fails.

    5. **Create step indicator** (`src/components/ui/step-indicator.tsx`):
       - Visual progress bar with 3 numbered circles connected by lines
       - States per step: completed (ember filled, checkmark), active (ember outlined), upcoming (gray outlined)
       - Step labels below circles: "Configure", "Upload", "Schema & Prompt"
       - Completed steps are clickable (call onStepChange)

    6. **Create Step 1: Configuration** (`src/components/wizard/step-config.tsx`):
       - "use client" component
       - Props: config data (from draft), onConfigChange, onNext
       - Three sections:
         a. **Priority Ranking**: Render `<PriorityRanker>`. Default order: accuracy, speed, cost.
         b. **Strategy Selection**: Render `<StrategyPicker>`. Three presets.
         c. **Sample Count**: Number input (1-10) with +/- buttons. Label: "How many sample images will you provide?"
       - On any change: debounce 500ms, then call saveDraftStep for config_data
       - "Continue" enables when all three are set (they always are via defaults)

    7. **Create priority ranker** (`src/components/wizard/priority-ranker.tsx`):
       Follow RESEARCH.md Pattern 7 EXACTLY for the @dnd-kit/react implementation:
       - Import `DragDropProvider` from `@dnd-kit/react`, `useSortable` from `@dnd-kit/react/sortable`, `move` from `@dnd-kit/helpers`
       - Three sortable items: Accuracy (Target icon), Speed (Zap icon), Cost (DollarSign icon)
       - Each item shows rank number (#1, #2, #3), icon, label, and brief description
       - Drag handle via GripVertical icon
       - Visual: rounded cards with surface-raised bg, ember rank badges
       - On drag end: call `move(items, source, target)` to reorder, then `onChange` with new order
       - Keyboard accessible: @dnd-kit handles this automatically

    8. **Create strategy picker** (`src/components/wizard/strategy-picker.tsx`):
       - Three card options (per user decision: named presets):
         a. **Quick Survey**: "Test many models with fewer runs. Fast results, broad coverage." Icon: Zap. Models: ~18-20, Runs per model: ~2-3.
         b. **Balanced**: "Recommended balance of breadth and depth." Icon: Scale/BarChart. Models: ~12-15, Runs per model: ~3-5. Mark as "Recommended" with ember badge.
         c. **Deep Dive**: "Fewer models, more runs per model. Higher confidence." Icon: Target. Models: ~6-8, Runs per model: ~5-8.
       - Cards: clickable, selected card has ember border, others have surface-border
       - Store as strategy ID string: 'quick-survey' | 'balanced' | 'deep-dive'

    9. **Draft auto-save:**
       - In wizard-shell or step-config: when config data changes, debounce 500ms, then PATCH `/api/drafts/[id]` with `{ step: 'config', data: configData }`
       - Show subtle "Saved" indicator (small text or checkmark) near the step title when save completes
       - On error: show toast/inline error "Failed to save draft"

    **Anti-patterns to AVOID:**
    - Do NOT store wizard state only in React state -- persist to database on changes
    - Do NOT use a single JSONB column for all steps -- use config_data, upload_data, schema_data separately
    - Do NOT block navigation to completed steps -- per user decision, free navigation is required
    - Do NOT build custom drag-and-drop -- use @dnd-kit/react for accessibility
  </action>
  <verify>
    1. `npm run build` succeeds
    2. Navigate to `/benchmark/new` -- wizard renders with Step 1 active, URL shows `?step=config`
    3. Drag priority items to reorder -- new order persists in state
    4. Click a strategy preset -- it highlights with ember border
    5. Change sample count -- value updates with +/- buttons
    6. Click "Continue" -- URL changes to `?step=upload`, step indicator updates
    7. Click "Configure" step in indicator -- returns to step 1 with data preserved
    8. Draft is created in database on page load and updated on step changes
  </verify>
  <done>
    Wizard shell renders at /benchmark/new with URL-persisted step state. Step 1 shows drag-to-rank priorities, strategy presets, and sample count selector. Draft is auto-created and auto-saved to Supabase. Step indicator allows free navigation between completed steps.
  </done>
</task>

<task type="auto">
  <name>Task 2: Step 2 (image upload with signed URLs, JSON editor, validation)</name>
  <files>
    src/components/wizard/step-upload.tsx
    src/components/wizard/image-uploader.tsx
    src/components/wizard/image-card.tsx
    src/components/wizard/json-editor.tsx
    src/app/api/upload/signed-url/route.ts
  </files>
  <action>
    **Build the image upload experience with JSON editing. Follow user decisions EXACTLY: list view of image cards, CodeMirror editor, inline validation, progression blocked until all JSON is valid.**

    1. **Create signed URL API route** (`src/app/api/upload/signed-url/route.ts`):
       Follow RESEARCH.md Pattern 4 EXACTLY:
       - POST handler: authenticate via `getUser()`, return 401 if not authenticated
       - Accept JSON body: `{ filename, contentType, draftId }`
       - Validate contentType is an accepted image type (JPEG, PNG, WebP) from constants
       - Validate file extension matches contentType
       - Generate storage path: `${user.id}/${draftId}/${nanoid()}.${ext}`
       - Call `supabase.storage.from('benchmark-images').createSignedUploadUrl(path)`
       - Return `{ signedUrl, token, path }`
       - Error handling: return 500 with error message on Supabase errors

    2. **Create image uploader component** (`src/components/wizard/image-uploader.tsx`):
       - "use client" component
       - Use `react-dropzone` with `useDropzone` hook
       - Accept: image/jpeg, image/png, image/webp
       - Max size: 10MB (from constants)
       - Max files: remaining slots (MAX_IMAGES - current count)
       - Drop zone UI: dashed border area with upload icon (Upload from lucide-react), "Drag & drop images here or click to browse", accepted formats text
       - On file drop:
         a. Validate file size and type client-side. Show error toast for rejected files.
         b. Create immediate thumbnail preview using `URL.createObjectURL(file)` for instant feedback
         c. For each file: POST to `/api/upload/signed-url` to get signed URL
         d. Upload file to Supabase Storage using `supabase.storage.from('benchmark-images').uploadToSignedUrl(path, token, file)`
         e. Get public URL via `supabase.storage.from('benchmark-images').getPublicUrl(path)`
         f. Add image entry to state: `{ id: nanoid(), path, publicUrl, localPreviewUrl, expectedJson: '', jsonValid: false, uploading: false }`
       - Show upload progress per file (loading spinner on image card during upload)
       - Disable drop zone when MAX_IMAGES reached, show "Maximum 10 images" message

    3. **Create image card component** (`src/components/wizard/image-card.tsx`):
       - "use client" component
       - Props: image entry data, onJsonChange, onRemove, isExpanded, onToggleExpand
       - Card layout (per user decision: list view):
         a. Left side: image thumbnail (64x64 or 80x80, object-cover, rounded). Click to expand (per user decision: starts as thumbnail, click to expand full preview).
         b. Center: image filename, upload status (uploading/uploaded), JSON status badge (valid/invalid/empty)
         c. Right side: "Edit JSON" button and remove (X) button
       - When expanded: show full image preview (max-w-md) AND the JSON editor below
       - JSON status indicator: green checkmark if valid, red X if invalid, gray dash if empty
       - Remove button: deletes from Supabase Storage and removes from state

    4. **Create JSON editor component** (`src/components/wizard/json-editor.tsx`):
       Follow RESEARCH.md Pattern 5 for CodeMirror setup:
       - "use client" component (CodeMirror is browser-only)
       - Import CodeMirror from `@uiw/react-codemirror`
       - Import `json()` and `jsonParseLinter` from `@codemirror/lang-json`
       - Import `linter` from `@codemirror/lint`
       - Import `vscodeDark` from `@uiw/codemirror-theme-vscode`
       - Props: `value`, `onChange`, `onValidChange(isValid, parsed)`
       - Extensions: `json()` for syntax support, `linter(jsonParseLinter())` for inline validation (red underlines per user decision)
       - Basic setup: line numbers, fold gutter, bracket matching
       - Header bar above editor: "expected_output.json" label + error message (if any)
       - Height: 300px
       - On change: parse JSON, call `onValidChange` with validity and parsed object
       - Per user decision: also support JSON file upload (.json). Add a small "Upload .json" button above the editor that opens a file picker, reads the file content, and populates the editor.

    5. **Create Step 2: Upload** (`src/components/wizard/step-upload.tsx`):
       - "use client" component
       - Props: upload data (from draft), draftId, onUploadChange, onNext
       - Layout:
         a. Top: `<ImageUploader>` drop zone
         b. Below: list of `<ImageCard>` components for each uploaded image
         c. Bottom: validation summary -- "X of Y images have valid JSON" with progress bar
       - State: array of ImageEntry objects (from types/wizard.ts)
       - On image upload: add to array, persist to draft upload_data
       - On JSON change for an image: update the entry, validate JSON, persist to draft
       - **Progression gate (per user decision: hard stop):**
         - "Continue" button disabled until ALL images have valid JSON
         - Show clear message when blocked: "All images must have valid JSON output before continuing. X images need JSON."
         - Also: at least MIN_IMAGES (1) images must be uploaded
       - Auto-save: debounce 500ms, PATCH draft with `{ step: 'upload', data: { images: [...] } }`

    6. **Image expanded state management:**
       - Track which image card is expanded (one at a time, or allow multiple -- choose one at a time for cleaner UX)
       - Click image thumbnail or "Edit JSON" to expand that card
       - Expanded state shows: full image preview + JSON editor + file upload option
       - Click image again or collapse button to minimize

    **Design considerations (Claude's discretion):**
    - Image cards: horizontal layout on desktop (image left, info center, actions right), stack on mobile
    - JSON editor: dark theme (vscodeDark) blends with void background
    - Upload zone: dashed border in surface-border color, hover state with ember dashed border
    - Progress indicator: ember colored fill bar showing "3/5 images have valid JSON"
    - Loading states: skeleton/spinner on image cards during upload
    - Error handling: toast or inline error for upload failures, retry option

    **Anti-patterns to AVOID:**
    - Do NOT upload images through Next.js API routes (bypasses Vercel 4.5MB limit) -- use Supabase Storage signed URLs for direct client-to-storage upload
    - Do NOT validate JSON only on form submit -- validate on every keystroke via CodeMirror linter extension
    - Do NOT skip client-side file size validation before upload
    - Do NOT render CodeMirror on the server -- it requires browser APIs. The wizard page is already "use client" so this is handled, but if refactored, use `dynamic(() => import('./json-editor'), { ssr: false })`
  </action>
  <verify>
    1. `npm run build` succeeds
    2. Navigate to Step 2 -- image uploader drop zone is visible
    3. Drop/select an image file -- thumbnail appears immediately, upload starts
    4. After upload completes, click image card to expand -- JSON editor appears
    5. Type invalid JSON -- red underlines appear inline in the editor
    6. Type valid JSON -- green status badge appears on the image card
    7. "Continue" button is disabled until all images have valid JSON
    8. Upload state is persisted to draft -- refresh page and data is restored
    9. Can navigate back to Step 1 and return to Step 2 with data preserved
  </verify>
  <done>
    Step 2 shows image upload zone accepting 1-10 images via drag-and-drop. Images upload directly to Supabase Storage via signed URLs with thumbnail previews. Each image has an expandable CodeMirror JSON editor with inline validation (red underlines for syntax errors). Progression is blocked until all images have valid JSON. All upload data persists to the draft database record.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes with zero errors
2. Full wizard flow: /benchmark/new loads Step 1 -> configure priorities/strategy/count -> Continue -> Step 2 -> upload images -> paste JSON -> Continue (blocked until all JSON valid)
3. URL reflects step: `?step=config`, `?step=upload`
4. Draft created on first visit, updated on each change, survives page refresh
5. Free navigation: can click any completed step header to go back
6. Image upload: drag-and-drop works, signed URLs bypass Vercel limit, thumbnails render immediately
7. JSON editor: syntax highlighting, bracket matching, inline validation errors
</verification>

<success_criteria>
- Wizard shell at /benchmark/new with 3-step indicator and URL-persisted state via nuqs
- Step 1: drag-to-rank priorities via @dnd-kit/react, strategy preset cards, sample count selector
- Step 2: drag-and-drop image upload via react-dropzone, Supabase Storage signed URL upload, CodeMirror JSON editor with inline validation
- Draft persistence: auto-save to Supabase on changes, resume on return
- Progression gate: Step 2 blocks advancement until all images have valid JSON
- Free navigation between completed steps
</success_criteria>

<output>
After completion, create `.planning/phases/01-configure-benchmark/01-03-SUMMARY.md`
</output>
