---
phase: 01-configure-benchmark
plan: 04
type: execute
wave: 4
depends_on: ["01-01", "01-02", "01-03"]
files_modified:
  - src/components/wizard/step-schema.tsx
  - src/components/wizard/schema-review.tsx
  - src/components/wizard/cost-preview.tsx
  - src/components/wizard/model-override.tsx
  - src/lib/schema/infer.ts
  - src/lib/schema/validate.ts
  - src/lib/wizard/presets.ts
  - src/lib/wizard/cost-estimator.ts
  - src/lib/wizard/model-recommender.ts
autonomous: true

must_haves:
  truths:
    - "User can see auto-inferred JSON schema from their uploaded examples"
    - "User can provide their own extraction prompt"
    - "User can override the auto-inferred schema with their own"
    - "User sees warning if schemas across images are incompatible (missing fields or type mismatches)"
    - "User sees cost preview card with estimated models, total runs, estimated time, and confidence level"
    - "User can see the system-suggested model set and add/remove individual models"
    - "Cost preview updates dynamically when user changes model selection or strategy"
    - "User can proceed to payment (ready state) only when all steps are complete and valid"
  artifacts:
    - path: "src/lib/schema/infer.ts"
      provides: "JSON schema inference from examples"
      exports: ["inferSchemaFromExamples"]
    - path: "src/lib/schema/validate.ts"
      provides: "Schema compatibility checking across images"
      exports: ["checkSchemaCompatibility"]
    - path: "src/lib/wizard/presets.ts"
      provides: "Strategy preset definitions with model/run allocations"
      exports: ["STRATEGY_PRESETS", "getPresetConfig"]
    - path: "src/lib/wizard/cost-estimator.ts"
      provides: "Cost estimation from config"
      exports: ["estimateCost"]
    - path: "src/lib/wizard/model-recommender.ts"
      provides: "Model recommendation based on priorities and strategy"
      exports: ["recommendModels"]
    - path: "src/components/wizard/step-schema.tsx"
      provides: "Step 3: schema review, prompt input, schema override"
      min_lines: 50
    - path: "src/components/wizard/cost-preview.tsx"
      provides: "Cost preview summary card with dynamic estimates"
      min_lines: 30
    - path: "src/components/wizard/model-override.tsx"
      provides: "Add/remove models from recommendation"
      min_lines: 30
  key_links:
    - from: "src/components/wizard/step-schema.tsx"
      to: "src/lib/schema/infer.ts"
      via: "inferSchemaFromExamples call"
      pattern: "inferSchemaFromExamples"
    - from: "src/components/wizard/step-schema.tsx"
      to: "src/lib/schema/validate.ts"
      via: "checkSchemaCompatibility call"
      pattern: "checkSchemaCompatibility"
    - from: "src/components/wizard/cost-preview.tsx"
      to: "src/lib/wizard/cost-estimator.ts"
      via: "estimateCost call"
      pattern: "estimateCost"
    - from: "src/components/wizard/model-override.tsx"
      to: "src/lib/wizard/model-recommender.ts"
      via: "recommendModels for initial set"
      pattern: "recommendModels"
    - from: "src/components/wizard/cost-preview.tsx"
      to: "src/lib/config/models.ts"
      via: "Model pricing data for cost calculation"
      pattern: "import.*models"
---

<objective>
Build wizard Step 3 (schema inference, compatibility checking, extraction prompt, schema override), the business logic layer (model recommendation, cost estimation, strategy presets), and the cost preview + model override UI. Connect all wizard steps into a complete flow ending at a "ready for payment" state.

Purpose: Complete the wizard experience so users can review their inferred schema, write an extraction prompt, see estimated costs, adjust model selection, and reach a state ready for Phase 2 payment. This plan delivers the intelligence layer that makes the wizard valuable -- not just data collection, but smart recommendations.
Output: Complete wizard flow from Step 1 through Step 3 with schema inference, cost estimates, model recommendations, and a "ready for payment" final state.
</objective>

<execution_context>
@/Users/lukelibraro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lukelibraro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-configure-benchmark/01-RESEARCH.md
@.planning/phases/01-configure-benchmark/01-CONTEXT.md
@.planning/phases/01-configure-benchmark/01-01-SUMMARY.md
@.planning/phases/01-configure-benchmark/01-02-SUMMARY.md
@.planning/phases/01-configure-benchmark/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schema inference, compatibility checking, and business logic (presets, cost estimator, model recommender)</name>
  <files>
    src/lib/schema/infer.ts
    src/lib/schema/validate.ts
    src/lib/wizard/presets.ts
    src/lib/wizard/cost-estimator.ts
    src/lib/wizard/model-recommender.ts
  </files>
  <action>
    **Build the pure business logic modules. These are all pure functions with no UI -- they power the wizard intelligence.**

    1. **Create schema inference** (`src/lib/schema/infer.ts`):
       Follow RESEARCH.md Pattern 6:
       - `inferSchemaFromExamples(examples: unknown[]): JSONSchema` -- Takes array of parsed JSON objects, returns a unified JSON Schema.
       - Use `@jsonhero/schema-infer`: call `inferSchema(examples[0])`, then for each subsequent example, call `inferSchema(examples[i], { existing: inference })` to merge.
       - Convert to JSON Schema via `inference.toJSONSchema()`.
       - Handle edge cases: single example (just infer from one), empty array (return empty object schema), non-object top-level (wrap in description).

    2. **Create schema compatibility checking** (`src/lib/schema/validate.ts`):
       Follow RESEARCH.md Pattern 6:
       - `checkSchemaCompatibility(examples: Array<{ imageIndex: number; json: unknown }>): { compatible: boolean; warnings: string[] }`
       - Check for key mismatches: If field "X" exists in some images but not others, warn: `Field "X" is missing from image(s) 2, 4. A single report uses one schema across all images.`
       - Check for type mismatches: If field "X" is number in image 1 but string in image 3, warn: `Field "X" has inconsistent types across images: number, string. This may cause inaccurate benchmarking.`
       - Check for union types in inferred schema: After inference, scan result for `anyOf` or type arrays. Warn: `Field "total" has different types across your images. Pick one format.`
       - Return `{ compatible: true/false, warnings: string[] }`. Compatible = no warnings.

    3. **Create strategy presets** (`src/lib/wizard/presets.ts`):
       - Define the `StrategyPreset` type: `{ id, name, description, icon, modelCount: { min, max }, runsPerModel: { min, max }, recommended?: boolean }`
       - `STRATEGY_PRESETS` array with three presets per user decision:
         a. `quick-survey`: "Quick Survey" -- Test many models (18-20) with fewer runs (2-3). Fast results, broad coverage.
         b. `balanced`: "Balanced" -- Recommended balance (12-15 models, 3-5 runs per model). Marked as recommended.
         c. `deep-dive`: "Deep Dive" -- Fewer models (6-8) with more runs (5-8). Higher statistical confidence.
       - `getPresetConfig(strategyId: string)`: Returns the preset object for the given ID.
       - Each preset includes a brief rationale explaining the tradeoff.

    4. **Create cost estimator** (`src/lib/wizard/cost-estimator.ts`):
       - `estimateCost(config: CostEstimateInput): CostEstimate`
       - Input: `{ selectedModels: ModelInfo[], runsPerModel: number, sampleCount: number }`
       - For each model: calculate cost per run = `(avgInputTokens * model.inputCostPer1k / 1000) + (avgOutputTokens * model.outputCostPer1k / 1000)`. Use conservative estimates for token counts: ~1500 input tokens per image (vision), ~500 output tokens per response.
       - Total cost = sum of (cost_per_run * runsPerModel * sampleCount) for all models.
       - Cap at API_BUDGET_CEILING ($7) from constants. If estimated cost exceeds ceiling, note that system will optimize runs-per-model internally.
       - Return: `{ estimatedCost: number, totalRuns: number, estimatedTimeMinutes: number, confidenceLevel: 'low'|'medium'|'high', budgetUtilization: number, warning?: string }`
       - Confidence level heuristic: <3 runs = low, 3-5 = medium, >5 = high.
       - Estimated time: ~3 seconds per run average (conservative), with parallelism factor of 3.
       - Add "Prices as of [PRICES_AS_OF_DATE]" disclaimer constant.

    5. **Create model recommender** (`src/lib/wizard/model-recommender.ts`):
       - `recommendModels(config: RecommendConfig): RecommendedModelSet`
       - Input: `{ priorities: Priority[], strategy: StrategyId, models: ModelInfo[] }` where models is the full curated list from config/models.ts
       - Logic:
         a. Filter models by tier based on strategy: quick-survey uses all tiers, balanced uses mid+premium, deep-dive focuses on premium+top-mid.
         b. Sort models by priority weighting: #1 priority gets 3x weight, #2 gets 2x, #3 gets 1x. For each model, compute score = sum(weight[i] * metric[i]) where metrics are accuracy_tier_score, speed_tier_score, cost_tier_score derived from tier and pricing.
         c. Select top N models based on strategy's modelCount range.
         d. Determine runs-per-model: start with strategy's runsPerModel range, then optimize within budget ceiling. Use the cost estimator to check if the configuration fits within $7. If not, reduce runs-per-model until it fits.
       - Return: `{ models: ModelInfo[], runsPerModel: number, reasoning: string }`. Reasoning: short sentence explaining the selection (e.g., "12 models selected with 4 runs each, prioritizing accuracy. Estimated $5.20 of $7.00 budget.").

    **Testing approach:**
    - These are pure functions. Test mentally by tracing inputs to outputs.
    - Edge cases to handle: empty model list, single image (no compatibility to check), budget exceeded by even 1 run per model (select fewer models).
  </action>
  <verify>
    1. `npm run build` succeeds with no TypeScript errors in any business logic file
    2. All exports are properly typed and importable
    3. `inferSchemaFromExamples([{ name: "test", total: 8.38 }])` would return a valid JSON Schema with string and number properties
    4. `checkSchemaCompatibility([{ imageIndex: 0, json: { a: 1 } }, { imageIndex: 1, json: { b: 2 } }])` would return warnings about missing fields
    5. `estimateCost` returns values within reasonable ranges (cost < $7, time < 30 min)
    6. `recommendModels` returns a subset of the curated model list that fits within budget
  </verify>
  <done>
    All business logic modules compile and export typed functions: schema inference from examples, schema compatibility checking with field-level warnings, strategy preset definitions, cost estimation with budget cap awareness, and model recommendation with priority-weighted scoring. These are pure functions ready to be consumed by the wizard UI.
  </done>
</task>

<task type="auto">
  <name>Task 2: Step 3 UI (schema review, prompt, override), cost preview, model override, and wizard completion flow</name>
  <files>
    src/components/wizard/step-schema.tsx
    src/components/wizard/schema-review.tsx
    src/components/wizard/cost-preview.tsx
    src/components/wizard/model-override.tsx
  </files>
  <action>
    **Build Step 3 UI and the cost preview / model override components. Connect everything into the complete wizard flow.**

    1. **Create schema review component** (`src/components/wizard/schema-review.tsx`):
       - "use client" component
       - Props: inferred schema (JSON Schema object), compatibility warnings, schemaSource ('auto'|'manual'), onSchemaOverride
       - Two modes:
         a. **Auto mode** (default): Display the inferred schema in a read-only CodeMirror editor (reuse json-editor but read-only). Show "Auto-detected from your examples" badge.
         b. **Manual mode**: User provides their own schema in an editable CodeMirror editor. Show "Custom schema" badge.
       - Toggle button: "Use custom schema" / "Use auto-detected schema"
       - If compatibility warnings exist: show warning box (amber/yellow) above the schema with each warning as a bullet point. Per user decision: "Warn if schemas across images are incompatible -- a report is for 1 prompt/schema with multiple datapoints."
       - If union types detected in inferred schema: additional warning about inconsistent types.

    2. **Create Step 3: Schema & Prompt** (`src/components/wizard/step-schema.tsx`):
       - "use client" component
       - Props: upload data (images with JSON), schema data (from draft), onSchemaChange, draftId
       - On mount: Extract parsed JSON from all images (from upload_data). Call `inferSchemaFromExamples(parsedJsonArray)` to generate schema. Call `checkSchemaCompatibility(examples)` to check for issues.
       - Layout:
         a. **Extraction Prompt** section: Large textarea for user to describe what they want extracted. Placeholder: "Describe what data should be extracted from these images. E.g., 'Extract all line items, totals, tax, vendor name, and date from this receipt.'" Minimum 20 chars to proceed.
         b. **Schema Review** section: Render `<SchemaReview>` with inferred schema and compatibility warnings.
         c. **Cost Preview & Model Selection** section: Render `<CostPreview>` and `<ModelOverride>` side by side (or stacked on mobile).
       - Auto-save schema_data to draft: `{ inferredSchema, userSchema, prompt, schemaSource }`
       - **Completion gate:**
         - Show "Ready for Payment" button (styled as prominent ember CTA) when:
           - Extraction prompt is provided (non-empty, min 20 chars)
           - Schema is set (auto or manual, valid JSON Schema)
           - No blocking compatibility errors (warnings are OK, just shown)
           - At least 1 model selected
         - On click "Ready for Payment": update draft status to 'ready', save selected_models and estimated_cost/estimated_runs to draft, persist schema_data. Then show a confirmation state or redirect to a pre-payment summary (for Phase 2 to pick up). For now, show a success state: "Benchmark configured! Payment will be available soon." with a "Return to Dashboard" link.
         - Per user decision: do NOT actually process payment in Phase 1. Just get to "ready" state.

    3. **Create cost preview component** (`src/components/wizard/cost-preview.tsx`):
       - "use client" component
       - Props: config (priorities, strategy, sampleCount), selectedModels, onChange (for triggering recalculation)
       - Call `estimateCost()` with current config to get estimates
       - Display as a summary card (per user decision: "summary card with estimates"):
         a. **Models to test**: "{N} models" with model tier breakdown (e.g., "6 premium, 4 mid-tier, 2 budget")
         b. **Total runs**: "{N} runs" (models * runsPerModel * sampleCount)
         c. **Estimated time**: "~{N} minutes"
         d. **Confidence level**: Badge showing Low/Medium/High with color (red/amber/green)
         e. **Estimated API cost**: "${X.XX} of $7.00 budget" with a thin progress bar showing utilization
       - If cost exceeds budget: show note "System will optimize runs per model to fit within budget"
       - Footer: "Prices as of {date}. Actual costs may vary slightly."
       - Reactivity: recalculate whenever config or selectedModels changes

    4. **Create model override component** (`src/components/wizard/model-override.tsx`):
       - "use client" component
       - Props: recommendedModels (from recommender), allModels (full curated list), selectedModels, onSelectedChange
       - Per user decision: "System suggests a model set based on priorities and strategy; user can add/remove models to override"
       - Layout:
         a. Section header: "Models to Test" with count badge
         b. Recommended set shown as chips/tags with model name and tier badge. Each has an X button to remove.
         c. "Add model" button that opens a dropdown/popover listing all curated models NOT in the current selection. Each model shows: name, provider, tier, cost/run estimate. Click to add.
         d. If user removes a recommended model or adds a non-recommended one: show subtle "Custom selection" badge to indicate override.
       - Model chips: colored by tier (premium=purple, mid=blue, budget=green) or by provider color
       - On change: trigger cost preview recalculation
       - Persist selected model IDs to draft

    5. **Wire wizard completion flow:**
       - Update `wizard-shell.tsx` (from Plan 03) to track completed steps. A step is complete when:
         - Step 1 (config): always complete (has defaults)
         - Step 2 (upload): all images have valid JSON, at least 1 image
         - Step 3 (schema): prompt provided (min 20 chars), schema set
       - Step indicator shows checkmarks on completed steps
       - "Continue" on Step 3 is replaced with the "Ready for Payment" CTA
       - Save final state to draft: update status to 'ready', save computed fields (selected_models array, estimated_cost, estimated_runs)

    **Design considerations (Claude's discretion):**
    - Cost preview card: bg-surface with ember accent on the confidence badge and budget bar
    - Model chips: small rounded pills with provider color dot, model name, and tier text
    - Schema review: monospace font in CodeMirror, same dark theme as Step 2 JSON editor
    - Prompt textarea: bg-surface-raised, min-height 100px, ember focus ring
    - Completion state: centered success message with checkmark icon, ember CTA for dashboard
    - Compatibility warnings: amber-500 background with darker border, warning triangle icon

    **Anti-patterns to AVOID:**
    - Do NOT skip schema compatibility checking -- per user decision, warn about incompatible schemas
    - Do NOT let users proceed without an extraction prompt -- it is required
    - Do NOT show a payment button (Phase 2) -- show "Ready for Payment" that sets status to 'ready'
    - Do NOT fetch live pricing from OpenRouter -- use hardcoded pricing data with "as of" disclaimer
  </action>
  <verify>
    1. `npm run build` succeeds
    2. Navigate through wizard: Step 1 -> Step 2 (upload image + add valid JSON) -> Step 3
    3. Step 3 shows: auto-inferred schema from uploaded JSON, extraction prompt textarea, cost preview, model selection
    4. Type extraction prompt (20+ chars) -- "Ready for Payment" button enables
    5. Cost preview card shows estimated models, runs, time, confidence, and API cost
    6. Can add/remove models from the recommended set
    7. Cost preview updates when models change
    8. If two images have different JSON structures, compatibility warnings appear
    9. Click "Ready for Payment" -- draft status updates to 'ready', success state shown
    10. Can navigate back to Steps 1 and 2 with data preserved
  </verify>
  <done>
    Step 3 renders schema review with auto-inference from uploaded examples, schema compatibility warnings, extraction prompt input, cost preview card with dynamic estimates, and model override UI. The complete wizard flow works end-to-end: configure (Step 1) -> upload images with JSON (Step 2) -> review schema, write prompt, see cost estimate (Step 3) -> set draft to "ready for payment" state. All state persists to database.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` completes with zero errors
2. Full end-to-end wizard flow: Step 1 (config) -> Step 2 (upload + JSON) -> Step 3 (schema + prompt + cost + models) -> "Ready for Payment"
3. Schema inference correctly generates JSON Schema from uploaded examples
4. Compatibility warnings appear when image JSONs have different structures
5. Cost preview shows realistic estimates that update dynamically
6. Model recommendation produces a reasonable model set based on priorities and strategy
7. User can add/remove models from the recommendation
8. Draft status transitions from 'draft' to 'ready' on completion
9. All data persists across page refresh
</verification>

<success_criteria>
- Step 3 shows auto-inferred schema, compatibility warnings, extraction prompt input, and schema override option
- Cost preview card displays estimated models, runs, time, confidence, and API cost dynamically
- Model override lets users add/remove models from the system recommendation
- Complete wizard flow ends at "ready for payment" state
- Schema inference uses @jsonhero/schema-infer to merge multiple examples
- Cost estimation respects the $7 API budget ceiling
- Model recommendation uses priority-weighted scoring with strategy-based filtering
- All wizard state (all 3 steps) persists to Supabase via draft record
</success_criteria>

<output>
After completion, create `.planning/phases/01-configure-benchmark/01-04-SUMMARY.md`
</output>
