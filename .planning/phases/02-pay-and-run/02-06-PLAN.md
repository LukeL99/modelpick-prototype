---
phase: 02-pay-and-run
plan: 06
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/wizard/step-upload.tsx
  - src/components/wizard/json-editor.tsx
  - src/components/wizard/image-card.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User pastes JSON into editor, saves card, navigates to Step 3, completes wizard, clicks Back to Edit, goes to Upload step, clicks Edit on card -- JSON data is present"
    - "JSON validation still works: valid JSON enables Save button, invalid JSON disables it"
    - "All existing tests pass after the change"
  artifacts:
    - path: "src/components/wizard/json-editor.tsx"
      provides: "Single combined onChange callback replacing separate onChange + onValidChange"
      contains: "onChange"
    - path: "src/components/wizard/step-upload.tsx"
      provides: "Single handleJsonUpdate callback that atomically sets expectedJson, jsonValid, and parsedJson"
      contains: "handleJsonUpdate"
    - path: "src/components/wizard/image-card.tsx"
      provides: "Updated props interface using single onJsonUpdate callback"
      contains: "onJsonUpdate"
  key_links:
    - from: "src/components/wizard/json-editor.tsx"
      to: "src/components/wizard/image-card.tsx"
      via: "onChange callback with (value, isValid, parsed) signature"
      pattern: "onChange\\(val.*isValid.*parsed"
    - from: "src/components/wizard/image-card.tsx"
      to: "src/components/wizard/step-upload.tsx"
      via: "onJsonUpdate callback prop"
      pattern: "onJsonUpdate"
    - from: "src/components/wizard/step-upload.tsx"
      to: "src/app/(app)/benchmark/new/page.tsx"
      via: "onImagesChange single atomic call with all fields"
      pattern: "expectedJson.*jsonValid.*parsedJson"
---

<objective>
Fix stale closure race condition that causes expectedJson to be silently overwritten with empty string, making JSON data appear lost when navigating back to the Upload step.

Purpose: UAT Test 2 ("Back-to-Edit Preserves Data") fails because `handleJsonChange` and `handleValidChange` in step-upload.tsx both close over the same `images` array. When JsonEditor.handleChange fires, it calls both callbacks synchronously. React 18 batches the two `setImages` calls, and the last writer (`handleValidChange`) wins -- overwriting the `expectedJson` set by `handleJsonChange` with the stale value from the closure (empty string on first edit).

Output: Single atomic callback that updates expectedJson + jsonValid + parsedJson in one onImagesChange call, eliminating the race.
</objective>

<execution_context>
@/Users/lukelibraro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lukelibraro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/debug/json-data-lost-on-back-nav.md

@src/components/wizard/json-editor.tsx
@src/components/wizard/step-upload.tsx
@src/components/wizard/image-card.tsx
@src/app/(app)/benchmark/new/page.tsx
@src/types/wizard.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Merge onChange + onValidChange into single atomic callback</name>
  <files>
    src/components/wizard/json-editor.tsx
    src/components/wizard/image-card.tsx
    src/components/wizard/step-upload.tsx
  </files>
  <action>
The root cause is two separate callbacks (`handleJsonChange` and `handleValidChange`) closing over the same stale `images` array and both calling `onImagesChange` synchronously. React 18 batches the updates and last writer wins, discarding `expectedJson`.

Fix by merging both updates into a single callback throughout the chain:

**1. json-editor.tsx -- Combine onChange and onValidChange into a single onChange callback**

Change the `JsonEditorProps` interface:
- Remove `onValidChange?: (isValid: boolean, parsed: unknown) => void`
- Change `onChange` signature to: `onChange: (value: string, isValid: boolean, parsed: unknown) => void`

In `handleChange`:
- Instead of calling `onChange(val)` then `onValidChange?.(isValid, parsed)` separately, call a single `onChange(val, isValid, parsed)` at each exit point:
  - Empty string case: `onChange(val, false, null)`
  - Valid JSON case: `onChange(val, true, parsed)`
  - Invalid JSON case: `onChange(val, false, null)`

In `handleFileUpload`:
- `handleChange(content)` is fine since handleChange now calls the combined onChange.

Keep the `error` state for display (setError still works as before for showing inline validation messages).

**2. image-card.tsx -- Replace two props with one combined prop**

Change `ImageCardProps`:
- Remove `onJsonChange: (value: string) => void`
- Remove `onValidChange: (isValid: boolean, parsed: unknown) => void`
- Add `onJsonUpdate: (value: string, isValid: boolean, parsed: unknown) => void`

In the editing state JSX where `<JsonEditor>` is rendered:
- Change from:
  ```
  onChange={onJsonChange}
  onValidChange={onValidChange}
  ```
- To:
  ```
  onChange={onJsonUpdate}
  ```
  (no onValidChange prop at all since it's been removed from JsonEditor)

**3. step-upload.tsx -- Replace handleJsonChange + handleValidChange with single handleJsonUpdate**

Remove `handleJsonChange` (lines 142-151) and `handleValidChange` (lines 153-164).

Add a single `handleJsonUpdate` callback:
```typescript
const handleJsonUpdate = useCallback(
  (imageId: string, value: string, isValid: boolean, parsed: unknown) => {
    onImagesChange(
      images.map((img) =>
        img.id === imageId
          ? { ...img, expectedJson: value, jsonValid: isValid, parsedJson: parsed }
          : img
      )
    );
  },
  [images, onImagesChange]
);
```

This performs a SINGLE onImagesChange call with ALL three fields updated atomically. No more race.

In the JSX where `<ImageCard>` is rendered, replace:
```
onJsonChange={(value) => {
  if (image) handleJsonChange(image.id, value);
}}
onValidChange={(isValid, parsed) => {
  if (image) handleValidChange(image.id, isValid, parsed);
}}
```
With:
```
onJsonUpdate={(value, isValid, parsed) => {
  if (image) handleJsonUpdate(image.id, value, isValid, parsed);
}}
```

**Important:** Do NOT change `handleFileForSlot`, `handleRemove`, or any other callback. Do NOT change `page.tsx` -- `handleImagesChange` and `onImagesChange` remain the same. The fix is isolated to the three files in the json-editing callback chain.
  </action>
  <verify>
1. `npx tsc --noEmit` -- no type errors (confirms all prop changes are consistent)
2. `npm test` -- all existing tests pass (no regressions)
3. `npm run build` -- build succeeds
  </verify>
  <done>
- JsonEditor calls a single `onChange(value, isValid, parsed)` instead of separate `onChange` + `onValidChange`
- ImageCard passes single `onJsonUpdate` prop to JsonEditor's `onChange`
- StepUpload's `handleJsonUpdate` produces one `onImagesChange` call with expectedJson, jsonValid, and parsedJson all set atomically
- No stale closure race: only ONE setImages call per keystroke, containing all updated fields
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm test` passes all existing tests
3. `npm run build` succeeds
4. Manual verification path (for UAT re-test): Upload image -> paste valid JSON -> Save -> continue to Step 3 -> complete wizard -> Back to Edit -> go to Upload step -> click Edit on card -> JSON data is present
</verification>

<success_criteria>
- UAT Test 2 gap resolved: expectedJson is preserved through the full navigation cycle
- Zero regressions: all existing tests pass, build succeeds
- The stale closure race is structurally eliminated (single callback = single setImages call)
</success_criteria>

<output>
After completion, create `.planning/phases/02-pay-and-run/02-06-SUMMARY.md`
</output>
