---
phase: 02-pay-and-run
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/(app)/benchmark/new/page.tsx
  - src/app/api/drafts/[id]/route.ts
  - src/components/wizard/step-schema.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Confirmation screen shows correct model count matching what user selected in wizard"
    - "Clicking 'Back to Edit' from confirmation screen preserves prompt, schema, and model selections"
    - "Mock payment succeeds (no 400 error) because schema_data retains selectedModelIds after handleComplete"
    - "No flash 'Benchmark Configured' page between wizard Step 3 and confirmation screen"
  artifacts:
    - path: "src/app/(app)/benchmark/new/page.tsx"
      provides: "savedSchemaData updated on every auto-save, handleComplete sends correct data"
      contains: "setSavedSchemaData"
    - path: "src/components/wizard/step-schema.tsx"
      provides: "No intermediate success page, completion handled by parent"
    - path: "src/app/api/drafts/[id]/route.ts"
      provides: "PATCH supports status-only updates without step/data"
  key_links:
    - from: "src/components/wizard/step-schema.tsx"
      to: "src/app/(app)/benchmark/new/page.tsx"
      via: "onSaveSchema callback updates savedSchemaData state"
      pattern: "setSavedSchemaData"
    - from: "src/app/(app)/benchmark/new/page.tsx"
      to: "src/components/wizard/confirmation-screen.tsx"
      via: "savedSchemaData?.selectedModelIds passed as selectedModels prop"
      pattern: "savedSchemaData\\?\\.selectedModelIds"
---

<objective>
Fix the wizard data flow so that schema data (prompt, selectedModelIds, schema) persists correctly through the confirmation and payment flow.

Purpose: UAT Tests 1, 2, 3, and 7 all fail because `savedSchemaData` React state in page.tsx is never updated during the wizard session, causing: (a) confirmation screen shows 0 models, (b) handleComplete overwrites schema_data in DB with `{}`, (c) flash "Benchmark Configured" success page, (d) back-to-edit loses prompt and selections. All share one root cause.
Output: Working wizard-to-confirmation-to-payment flow with correct data at every step.
</objective>

<execution_context>
@/Users/lukelibraro/.claude/get-shit-done/workflows/execute-plan.md
@/Users/lukelibraro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-pay-and-run/02-01-SUMMARY.md
@.planning/debug/02-confirmation-screen.md
@.planning/debug/02-mock-payment-models.md

Key source files:
@src/app/(app)/benchmark/new/page.tsx
@src/components/wizard/step-schema.tsx
@src/components/wizard/confirmation-screen.tsx
@src/app/api/drafts/[id]/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix savedSchemaData sync and handleComplete data correctness</name>
  <files>src/app/(app)/benchmark/new/page.tsx, src/app/api/drafts/[id]/route.ts</files>
  <action>
Two files need changes:

**FILE 1: `src/app/(app)/benchmark/new/page.tsx`**

**Fix 1 -- Update savedSchemaData in handleSaveSchema (lines 267-286):**

The `handleSaveSchema` callback currently calls `saveDraftStep("schema", ...)` to persist to DB but NEVER calls `setSavedSchemaData()`. Add a `setSavedSchemaData()` call so the React state stays in sync with what was saved to DB.

In `handleSaveSchema`, BEFORE the `saveDraftStep(...)` call (so state updates even if the network save is slow), add:
```typescript
setSavedSchemaData({
  inferredSchema: data.inferredSchema,
  userSchema: data.userSchema,
  prompt: data.prompt,
  schemaSource: data.schemaSource,
  selectedModelIds: data.selectedModelIds,
});
```

Place this BEFORE the `saveDraftStep` call. The full handleSaveSchema should look like:
```typescript
const handleSaveSchema = useCallback(
  (data: {
    inferredSchema: Record<string, unknown> | null;
    userSchema: string;
    prompt: string;
    schemaSource: SchemaSource;
    selectedModelIds: string[];
    estimatedCost: number;
    estimatedRuns: number;
  }) => {
    // Keep React state in sync with auto-saved data
    setSavedSchemaData({
      inferredSchema: data.inferredSchema,
      userSchema: data.userSchema,
      prompt: data.prompt,
      schemaSource: data.schemaSource,
      selectedModelIds: data.selectedModelIds,
    });

    saveDraftStep("schema", {
      inferredSchema: data.inferredSchema,
      userSchema: data.userSchema,
      prompt: data.prompt,
      schemaSource: data.schemaSource,
      selectedModelIds: data.selectedModelIds,
    });
  },
  [saveDraftStep]
);
```

This ensures that every 500ms auto-save from StepSchema updates both the DB and the local React state.

**Fix 2 -- Defensive handleComplete (lines 289-315):**

With Fix 1 in place, `savedSchemaData` is now always in sync. Update handleComplete to conditionally include step/data only when savedSchemaData is available, and remove `saveDraftStep` from the dependency array:

```typescript
const handleComplete = useCallback(async () => {
  if (!draftId) return;
  setSaveStatus("saving");
  try {
    const body: Record<string, unknown> = { status: "ready" };
    // Only re-save schema data if we have it (should always be true after auto-save)
    if (savedSchemaData) {
      body.step = "schema";
      body.data = savedSchemaData;
    }

    const res = await fetch(`/api/drafts/${draftId}`, {
      method: "PATCH",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    if (res.ok) {
      setSaveStatus("saved");
      setCompletedSteps(
        (prev) => new Set([...prev, "config", "upload", "schema"])
      );
      setShowConfirmation(true);
    } else {
      setSaveStatus("error");
    }
  } catch {
    setSaveStatus("error");
  }
}, [draftId, savedSchemaData]);
```

Note: `saveDraftStep` removed from deps since it is not used in the function body.

**FILE 2: `src/app/api/drafts/[id]/route.ts`**

The PATCH endpoint currently REQUIRES `step` and `data` (returns 400 if missing). Update to support status-only updates as a fallback.

Change the validation and save block (lines 70-81) from:
```typescript
if (!step || !data || !["config", "upload", "schema"].includes(step)) {
  return NextResponse.json(
    { error: "Invalid request. Requires step ('config'|'upload'|'schema') and data." },
    { status: 400 }
  );
}

// Save step data
await saveDraftStep(supabase, id, step, data);
```

To:
```typescript
// Step save (optional -- status-only updates skip this)
if (step) {
  if (!data || !["config", "upload", "schema"].includes(step)) {
    return NextResponse.json(
      { error: "Invalid request. Step requires valid name ('config'|'upload'|'schema') and data." },
      { status: 400 }
    );
  }
  await saveDraftStep(supabase, id, step, data);
} else if (!status) {
  // Neither step nor status provided -- nothing to do
  return NextResponse.json(
    { error: "Invalid request. Requires step and data, or status." },
    { status: 400 }
  );
}
```

The rest of the function (status update block starting at line 84) stays the same. This allows handleComplete to send status-only when savedSchemaData is null (edge case safety).
  </action>
  <verify>
1. `npx tsc --noEmit` passes (no type errors)
2. `npm run build` succeeds
3. Grep confirms: `setSavedSchemaData` is called inside `handleSaveSchema`
4. Grep confirms: handleComplete references `savedSchemaData` and conditionally sends it
5. Grep confirms: PATCH route allows `step` to be optional
  </verify>
  <done>
savedSchemaData is updated on every auto-save from StepSchema. handleComplete sends the correct schema data to the PATCH endpoint. ConfirmationScreen receives the correct selectedModelIds from savedSchemaData. API endpoint supports status-only updates as fallback.
  </done>
</task>

<task type="auto">
  <name>Task 2: Remove flash success page from StepSchema</name>
  <files>src/components/wizard/step-schema.tsx</files>
  <action>
Remove the intermediate "Benchmark Configured!" success state from StepSchema that causes the ~1 second flash before the parent shows the confirmation screen.

**Changes in `src/components/wizard/step-schema.tsx`:**

1. **Remove the `isComplete` state entirely** (line 116): Delete `const [isComplete, setIsComplete] = useState(false);`

2. **Remove the success page render block** (lines 235-259): Delete the entire `if (isComplete) { return (...) }` block that renders the "Benchmark Configured!" page with the CheckCircle2 icon and "Return to Dashboard" link.

3. **Update handleComplete** (lines 228-232): Remove `setIsComplete(true)`. The function should just call `onComplete()` if `canComplete` is true:
```typescript
const handleComplete = useCallback(() => {
  if (!canComplete) return;
  onComplete();
}, [canComplete, onComplete]);
```

4. **Clean up unused imports from lucide-react**: `ArrowRight` was only used in the removed success page block. Remove it from the import. `CheckCircle2` IS still used in the "Ready for Payment" button (line 357), so keep it.

The parent page.tsx `handleComplete` (the `onComplete` callback) will handle showing the confirmation screen via `setShowConfirmation(true)` after the async API call completes. During the API call, StepSchema remains visible (the user sees the Schema and Prompt step with its content), providing a smooth transition with no flash.
  </action>
  <verify>
1. `npx tsc --noEmit` passes (no type errors)
2. `npm run build` succeeds
3. Grep confirms: No `isComplete` state in step-schema.tsx
4. Grep confirms: No "Benchmark Configured" text in step-schema.tsx
5. Grep confirms: `ArrowRight` is not imported in step-schema.tsx
  </verify>
  <done>
StepSchema no longer shows an intermediate success page. Clicking "Ready for Payment" calls onComplete() which triggers the parent's async handleComplete. The user sees the schema step during the API call, then transitions directly to the confirmation screen.
  </done>
</task>

</tasks>

<verification>
After both tasks, verify the complete data flow:
1. `npm run build` passes
2. `npm test` -- all existing 50 tests pass
3. Check that savedSchemaData is updated by handleSaveSchema (code inspection)
4. Check that StepSchema no longer has isComplete state or "Benchmark Configured" text
5. Check that PATCH endpoint supports status-only updates
</verification>

<success_criteria>
- Confirmation screen displays the correct number of selected models (not 0)
- No flash "Benchmark Configured" page between Step 3 and confirmation
- "Back to Edit" preserves prompt, schema source, and model selections
- Mock payment succeeds (no "No valid models selected" 400 error)
- schema_data in DB retains selectedModelIds after handleComplete
- `npm run build` passes
- All existing tests pass (`npm test`)
</success_criteria>

<output>
After completion, create `.planning/phases/02-pay-and-run/02-04-SUMMARY.md`
</output>
